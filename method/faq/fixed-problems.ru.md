# Типичные проблемы веб-разработчика и способы их решения с БЭМ

БЭМ-методология задает ряд [правил по именованию CSS-селекторов](../naming/naming.ru.md), соблюдение которых решает многие проблемы веб-разработки:

* [Как уменьшить сложность кода.](#bem-simple-code)
* [Как начать повторно использоваь код.](#bem-reuse-code)
* [Как избежать взаимного влияния компонентов друг на друга и упростить рефакторинг.](#bem-split-code)
* [Как понять, о какой конкретно сущности идет речь. Определение всех частей сущности в отрыве от контекста.](#bem-clarify-code)

<a name="bem-simple-code"></a>
## Как уменьшить сложность кода в современном фронтенде

Распространенная ситуация: пока разработчик работает над проектом, он называет, казалось бы, очевидные вещи своими именами. Ему понятно, какие компоненты интерфейса для чего служат и за что отвечают.

Например, для создания простого навигационного меню могут использоваться следующие имена классов:

```html
<ul class="nav">
    <li class="item active"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

К ним будут написаны вполне понятные CSS-правила, например:

```css
.item
{
    padding: 4px 10px;
    color: black;
}

.active
{
    font-weight: bold;
    background: #ffc7c7;
}
```

> **Проблема**

Пока работа над проектом продолжается, разработчик помнит, какие компоненты могут использовать класс `active`. Но, если проект приходится поддерживать, то вернувшись к коду через пару месяцев, мало кому удается сразу вспомнить, на что могут повлиять правила данного селектора.

Вполне может оказаться, что на других страницах существует еще несколько вариантов использования класса `active`, например, `.link.active`.

В таком случае, чтобы разобраться, можно ли безболезненно изменить стили для `.active`, разработчику придется просмотреть всю структуру страницы или даже проекта.

А теперь представьте такую же ситуацию с большим проектом — любое изменение потребует огромных временных затрат только на поиск зависимых компонентов.

Пока разработчик справляется с тем количеством данных, которые можно удержать в голове, он можете успевать вовремя делать все необходимые изменения в коде. Но при переключении на другой проект или добавлении в существующий еще десятка страниц, такие связи становится сложно проследить.

> **Решение**

Методология БЭМ помогает легко отслеживать все связи между компонентами в пределах проекта при помощи соглашения по именованию CSS-классов.

Рассмотрим этот же пример, но уже с примененными правилами именования БЭМ: класс `nav` будет обозначать имя блока, `nav__item` — имя элемента, а `nav__item_active` — имя его модификатора. В таком случае запись будет следующей:

```html
<ul class="nav">
    <li class="nav__item nav__item_active"><a class="nav__link">One</a></span></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

И, соответственно, CSS будет иметь такой вид:

```css
.nav__item
{
    padding: 4px 10px;
    color: black;
}

.nav__item_active
{
    font-weight: bold;
    background: #ffc7c7;
}
```

Новые имена CSS-классов достаточно информативны, чтобы разработчику не пришлось заглядывать в HTML-код страницы. Cелектор всегда будет содержать знания о том, что данные правила влияют только на изменение конкретного блока или его элемента (в данном случае элемента `nav__item`). Разработчику не придется думать о возможном существовании `.link.active`, так как его CSS-правила будут записаны как `.link_active` и не будут зависеть от правил модификатора `active` для пункта меню.

>Такой подход имеет два потенциальных минуса:

>* Результирующий код весит больше. Эту проблему полностью решает `gzip`, который отлично сжимает повторяющиеся последовательности и сводит минус на нет.
>* Длинные имена классов писать долго. С этой проблемой помогают справиться автокомплит в редакторе и инструментарий, который автоматически добавляет префиксы (CSS-препроцессоры и шаблонизаторы).

>Однако совершенно очевидно, что затраты времени, необходимые на написание длинных имен классов, намного меньше, чем на обдумывание архитектуры.

Применение правил по именованию, предложенных БЭМ-методолгией, позволяет:

* задать явные связи между разными сущностями;
* определить типы сущностей по их [именам](../naming/naming.ru.md);
* упростить восприятие кода.

Помимо всего вышеперечисленного, использование методологии БЭМ дает возможность получить **самодокументируемый код** проекта без дополнительных усилий.

<a name="bem-clarify-code"></a>
### Самодокументируемый код

Большинство разработчиков при переходе между проектами сталкивались с проблемой отсутствия документации.

В поддержке кода важно минимизировать время, которое разработчик тратит на то, чтоб понять, как все устроено, где что лежит и как работает. Порой именно на такое изучение уходит большая часть времени, а вовсе не на реализацию функциональности или исправление ошибки.

Одна из целей БЭМ — рассказать другим разработчикам как можно больше о том, что делает тот или иной код, по названиям классов в разметке. Идея самодокументируемого кода заключается в том, чтобы при взгляде на названиям CSS-классов, переменных и функций было понятно, как работает код.

Используя БЭМ Читая HTML с небольшим количеством классов внутри, можно увидеть взаимодействие отдельных компонентов кода; что-то может быть независимым блоком, что-то дочерним компонентом — элементом этого блока, а что-то может видоизменять блок или элемент — модификатор блока или элемента.

Используя соглашения по именованию БЭМ-сущностей, разработчик сразу способен понять всю анатомию блока, не заглядывая в HTML:

* о каком блоке идет речь, и какую часть интерфейса он реализует;
* из каких частей (элементов или других блоков) он состоит;
* каким изменениям подвергается блок благодаря тем или иным модификаторам.

Давайте рассмотрим пример с формой поиска на сайте. Не будем обращаться к HTML, попробуем прочитать только CSS и понять, какую часть интерфейса он описывает.

Для начала представим как бы такая форма могла быть реализована при классической верстке:

```css
form {}

input
{
    bacground: red;
}

input[type=submit]
{
    background: buttonface
}
```

Такая форма записи не дает разработчику никаких сведений о взаимодействии компонентов: невозможно определить, к чему относятся данные селекторы. Использование глобальных селекторов делает код проекта нерасширяемым — при попытке рефакторинга могут быть затронуты многие правила будут поломаны.

невозможно отрефакторить одну маленткую часть, так как изменения затронут слишком большие изменения

Попытаемся немного улучшить данный код — напишем CSS на классы:

```css
.form {}
.field {}
.submit {}
```

Код стал немного информативнее, но он все еще не дает понять, относится ли поле (`field`) к форме (`form`) или что может произойти, если полей или форм на странице будет несколько.

Перепишем пример, используя БЭМ:

```css
.form {}
.form_search {}
.form__field {}
.form__submit-button {}
```

Такая запись дает полное понимание того, как работает данный код. Только из имен CSS-классов видно, что:

* Существует некий блок `form`.
* Форма здесь представлена уже не просто как абстрактная сущность: благодаря модификатору `form_search` можно понять, что речь идет о форме поиска.
* У этой формы есть вложенные элементы: поле `form__field` и кнопка `form__submit-button`.

Такое именование сущностей позволяет понять структуру блока на без подробного изучения HTML. Даже если на странице будет еще одно поле `field`, то его правила никак не будут влиять на поле, описанное в поисковой форме, так как оно, скорее всего, будет реализовано, как элемент нового блока и будет иметь свое специфичное имя.

Жесткие правила именования в БЭМ позволяют сделать код вашего проекта прозрачным, однозначным и, как следствие, информативным. Это снижает порог входа для других разработчиков: не прилагая дополнительных усилий вы получаете самодокументируемый код.

<a name="bem-split-code"></a>
## Меняем CSS-правила одного компонента страницы и при этом не ломаем другие

Описывая страницу, зачастую оперируют одними и той и же разметкой (сниппетами): всевозможные пункты могут встречаться в совершенно различных ситуациях, ссылок на странице может быть множество, при этом какие-то из них должны уводить читателя на другую страницу, какие-то просто облегчать навигацию по странице.

Рассмотрим пример с навигационным меню:

```html
<ul class="nav">
    <li class="item"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

CSS-стили к пункту `item` в нем, скорее всего, будут записаны как:

```css
.item
{
    padding: 4px 10px;
    color: black;
}
```

Если на страницу понадобится добавить дополнительные компоненты, содержащие пункты, то появится еще один блок кода с классом `item`, например:

```html
<div class="snippets">
    <div class="item">
        <h2 class="title"></h2>
        <img class="thumb">
    </div>
</div>
```

Вероятность того, что CSS-правила будут оформлены с помощью каскада возрастает, не зря ведь CSS назван Cascading Style Sheets.

```css
.item
{
    padding: 4px 10px;
    color: black;
}

.snippets .item
{
    color: red;
    font-size: 14px;
}
```

Такой подход кажется вполне удобным и логичным: необходимо просто доопределить правила, уже написанные для `item`.

> Проблема

Подобный код может совершенно безболезненно так существовать и работать до тех пор, пока не возникнет необходимость изменить страницу, переместить какие-то пункты меню, использовать написанный код в другом месте отдельно от родителя или вложить навигационное меню в сниппетс.

Как только понадобится выполнить какое-то из вышеперечисленных действий, всплывет проблема того, что, казалось бы, независимые части кода слишком связаны и влияют друг на друга. Нет возможности исправить какой-то один компонент, не затронув так или иначе стили другого.

Изменения стилей одного компонента страницы, могут вызвать неожиданный «сюрприз» в виде сломанного зависимого компонента в другой части проекта.

> Решение

Правила по именованию CSS-селекторов в БЭМ дают возможность вносить изменения точечно, не ломая зависимые компоненты. В БЭМ каждый компонент имеет уникальное имя и является самодостаточным.

Запишем тот же код в соответствии с правилами именования БЭМ:

```html
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

```css
.nav__item
{
    padding: 4px 10px;
    color: black;
}
```

В таком случае добавление нового пункта на страницу ничего не сломает — у пункта `snippets` появится свое специфичное имя `snippets__item`.

```html
<div class="snippets">
    <div class="snippets__item">
        <h2 class="snippets__title"></h2>
        <img class="snippents__thumb">
    </div>
</div>
```

Пункт `snippets__item` будет иметь соответствующие только ему уникальные CSS-правила:

```css
.snippets__item
{
    padding: 4px 10px;
    color: red;
    font-size: 14px;
}
```

Внесенные изменения в `nav__item` никак не отобразятся на пункте `snippets__item`.

Прозрачное именование блоков, элементов и модификаторов и уход от каскадов позволят вносить изменения только в конкретные компоненты и иметь четкое представление, к какому блоку относится каждый элемент и какие стили могут на него влиять.

Таким образом, элемент `item` получает уникальные независимые CSS-стили благодаря неймспейсам в виде имен блоков. Такой подход дает возможность защитить элементы от взаимного влияния друг на друга — элементы всегда являются частью блока. Такой же принцип работы использует и Shadow DOM в Web Components. Но, в отличие от Shadow DOM, применение БЭМ-нотации не зависит от поддержки браузеров.

Блоки `snippets` и `nav` можно повторно использовать на других страницах или в другом проекте. Уникальность имен классов, основанная на правилах именования БЭМ, позволяет блокам не зависеть друг от друга.

Независимость блоков касается не только CSS. В БЭМ блок является абсолютно самодостаточной единицей. Он знает о себе все: свой внешний вид (CSS), поведение (JavaScript) и шаблоны и перечень блоков, с которыми ему необходимо взаимодействовать (зависимости).

// сослаться на док «Зачем БЭМ в JavaScript»


### Использование каскадов в БЭМ

Из предыдущей главы может сложиться впечатление, что методология БЭМ полностью отрицает каскады в CSS. Это не совсем так — каскады в БЭМ существуют, но встречаются значительно реже.

Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока.

**Пример**

```
.nav_hovered .nav__link
{
    text-decoration: underline;
}
```

или темы

```
.nav_theme_islands .nav__item
{
    line-height: 1.5;
}
```

В случае использования каскада повышается вероятность связанности кода, что делает его повторное использование невозможным и увеличивает риски попасть в ситуацию, когда переписать проще, чем исправить.

## Миксы, или как разместить несколько сущностей на одном DOM-узле

Воспользуемся еще раз нашим примером, который реализует универсальный блок навигационного меню. Такой блок можно использовать в совершенно различных случаях.

```
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

Может возникнуть необходимость применить его в составе нового блока. Допустим, отображать с его помощью какие-то статьи в блоке новостей. В таком случае воздействовать на блок `nav` с помощью модификаторов — не самый хороший выбор, так как семантически `nav` будет уже принципиально другим блоком — блоком новостей.

Решить такую задачу можно при помощи [микса]() двух блоков. То есть смешать на одном DOM-узле два разных блока: блок `nav` и `articles`. Блок `articles`, предположим, будет отвечать за внешний вид новостных статей в меню.

пересмотреть пример -

```html
<ul class="nav articles">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

При этом такая реализация будет содержать всю функциональность блока `nav`, а также особенности реализации блока `articles`.

>Точно так же можно смешивать блоки с элементами [и не только](ссылка на difinitions в раздел). Подробнее про варианты смотри в дефинитионс

Снова вернемся к нашему примеру. В нем используется ссылка в качестве элемента блока `nav` — `nav__link`. Но в //проекте ссылка вполне может быть и отдельным блоком.

Например, в //проекте все ссылки изначально должны быть реализованы одинаково. Для этого создается блок `link` и его CSS-правила `.link { color: blue }`. Но может возникнуть необходимость сделать ссылки в навигационном меню шапки немного больше и заметнее.

В такой ситуации также удобно воспользоваться миксом — в этот раз смешать на одном DOM-узле блок и элемент другого блока. В нашем случае это будет блок `link` и элемент `nav__link`.

Нет смысла создавать еще один блок, можно просто добавить специфические правила для ссылки, актуальные только навигационному меню, расположенному в шапке:

```
.nav__link
{
   font-size: 14px;
   font-weight: bold;
}
```

Для того, чтобы стили `nav__link` применились к ссылкам в меню, нужно просто подмешать к блоку `link` элемент `nav__link`.

Пример вполне может выглядеть так:

```html
<ul class="nav">
    <li class="nav__item">
        <a class="link nav__link"></a>
    </li>
</ul>
```

При этом все общее, что есть у всех ссылок в проекте, будет описано в блоке `link`, а особенности, присущие только ссылке внутри `nav`, в `nav__link`.

ВЫВОД
Таким образом мы избежали каскада и разнесли

